// ::: Code Generated by Copilot [6d97f7be-92ae-4d44-a84f-a5b08cc4a78d]. This comment will be removed automatically after the file is saved :::
// ::: Code Generated by Copilot [61f683f6-7398-4556-ab39-00f7036a617a]. This comment will be removed automatically after the file is saved :::
package com.datalift

import ai.onnxruntime.OnnxTensor
import ai.onnxruntime.OrtEnvironment
import ai.onnxruntime.OrtException
import ai.onnxruntime.OrtSession
import android.graphics.Bitmap
import android.graphics.Color
import org.json.JSONObject
import java.io.File
import java.nio.FloatBuffer
import java.nio.LongBuffer
import kotlin.math.max
import kotlin.math.min

// ::: Code Generated by Copilot [6d97f7be-92ae-4d44-a84f-a5b08cc4a78d]. This comment will be removed automatically after the file is saved :::
class LayoutLMv3OnnxEngine {
  // ::: Code Generated by Copilot [61f683f6-7398-4556-ab39-00f7036a617a]. This comment will be removed automatically after the file is saved :::
  private val minimumTokenConfidence = 0.88

  data class Prediction(
    val used: Boolean,
    val runtime: String,
    val confidence: Double,
    val fields: Map<String, Any>,
    val warnings: List<String>,
  )

  private var env: OrtEnvironment? = null
  private var session: OrtSession? = null
  private var loadedModelPath: String? = null

  private fun getEnv(): OrtEnvironment {
    if (env == null) env = OrtEnvironment.getEnvironment()
    return env!!
  }

  private fun getSession(modelPath: String): OrtSession {
    if (session != null && loadedModelPath == modelPath) return session!!
    session?.close()
    val options = OrtSession.SessionOptions()
    session = getEnv().createSession(modelPath, options)
    loadedModelPath = modelPath
    return session!!
  }

  fun predict(
    modelPath: String,
    labelsPath: String?,
    text: String,
    image: Bitmap?,
    maxSeqLen: Int = 128,
    imageSize: Int = 224,
  ): Prediction {
    // ::: Code Generated by Copilot [f192f767-a4a2-43d0-b5c6-d3029d2dd39a]. This comment will be removed automatically after the file is saved :::
    val modelFile = File(modelPath)
    if (!modelFile.exists()) {
      throw IllegalArgumentException("LayoutLMv3 model file not found: $modelPath")
    }
    val labelsResolved = labelsPath?.takeIf { it.isNotBlank() }
      ?: throw IllegalArgumentException("LayoutLMv3 labels file is required for reliable decoding")
    if (!File(labelsResolved).exists()) {
      throw IllegalArgumentException("LayoutLMv3 labels file not found: $labelsResolved")
    }

    val session = try {
      getSession(modelPath)
    } catch (e: OrtException) {
      throw IllegalStateException("Failed to load ONNX session: ${e.message}", e)
    }

    val labels = loadLabels(labelsResolved)
    validateLabelMap(labels)
    val vocab = loadVocab(modelFile.parentFile)
    val tokens = text.split("\\s+".toRegex()).filter { it.isNotBlank() }

    val encoded = encodeTokens(tokens, vocab, maxSeqLen)
    val pixelValues = imageToTensorData(image, imageSize)

    val inputs = mutableMapOf<String, OnnxTensor>()
    val inputIdsTensor = OnnxTensor.createTensor(
      getEnv(),
      LongBuffer.wrap(encoded.inputIds),
      longArrayOf(1, maxSeqLen.toLong()),
    )
    val attentionTensor = OnnxTensor.createTensor(
      getEnv(),
      LongBuffer.wrap(encoded.attentionMask),
      longArrayOf(1, maxSeqLen.toLong()),
    )
    val bboxTensor = OnnxTensor.createTensor(
      getEnv(),
      LongBuffer.wrap(encoded.bbox),
      longArrayOf(1, maxSeqLen.toLong(), 4),
    )
    val imageTensor = OnnxTensor.createTensor(
      getEnv(),
      FloatBuffer.wrap(pixelValues),
      longArrayOf(1, 3, imageSize.toLong(), imageSize.toLong()),
    )

    val tokenTypeTensor = OnnxTensor.createTensor(
      getEnv(),
      LongBuffer.wrap(LongArray(maxSeqLen) { 0L }),
      longArrayOf(1, maxSeqLen.toLong()),
    )

    try {
      for (name in session.inputNames) {
        when {
          name.equals("input_ids", true) -> inputs[name] = inputIdsTensor
          name.equals("attention_mask", true) -> inputs[name] = attentionTensor
          name.equals("bbox", true) -> inputs[name] = bboxTensor
          name.equals("pixel_values", true) -> inputs[name] = imageTensor
          name.equals("token_type_ids", true) -> inputs[name] = tokenTypeTensor
        }
      }

      val results = session.run(inputs)
      val logitsCandidate = results.firstOrNull()?.value
      val logits = logitsCandidate?.let { extract3DLogits(it) }
        ?: throw IllegalStateException(
          "Model output does not contain token logits. Use a LayoutLMv3 token-classification ONNX model.",
        )

      val entities = decodeEntities(logits, encoded.tokens, labels)
      val fields = entitiesToFields(entities)

      val confidence = entities.maxOfOrNull { it.score } ?: 0.0
      val warnings = mutableListOf<String>()
      if (entities.isEmpty()) {
        warnings += "No high-confidence entities survived post-processing"
      }
      if (fields.isEmpty()) {
        warnings += "No validated schema fields could be derived from model predictions"
      }

      return Prediction(
        used = fields.isNotEmpty(),
        runtime = "onnxruntime-android",
        confidence = confidence,
        fields = fields,
        warnings = warnings,
      )
    } finally {
      resultsSafeClose(inputs)
    }
  }

  private fun resultsSafeClose(inputs: Map<String, OnnxTensor>) {
    inputs.values.forEach {
      try {
        it.close()
      } catch (_: Exception) {
      }
    }
  }

  private data class Encoded(
    val inputIds: LongArray,
    val attentionMask: LongArray,
    val bbox: LongArray,
    val tokens: List<String>,
  )

  private fun encodeTokens(
    words: List<String>,
    vocab: Map<String, Int>,
    maxSeqLen: Int,
  ): Encoded {
    val cls = 101L
    val sep = 102L
    val unk = 100L
    val cleanWords = words.take(max(0, maxSeqLen - 2))

    val seqTokens = mutableListOf("[CLS]")
    seqTokens.addAll(cleanWords)
    seqTokens.add("[SEP]")

    val inputIds = LongArray(maxSeqLen) { 0L }
    val attention = LongArray(maxSeqLen) { 0L }
    val bbox = LongArray(maxSeqLen * 4) { 0L }

    for (i in seqTokens.indices) {
      val token = seqTokens[i]
      val tokenId = when (token) {
        "[CLS]" -> cls
        "[SEP]" -> sep
        else -> {
          val fromVocab = vocab[token.lowercase()]
          (fromVocab ?: (absStableHash(token) % 30000 + 1000)).toLong()
        }
      }
      inputIds[i] = tokenId
      attention[i] = 1L

      val x0 = 0L
      val y0 = ((i * 1000L) / max(1, seqTokens.size)).coerceIn(0L, 999L)
      val x1 = 1000L
      val y1 = min(1000L, y0 + 10L)
      val base = i * 4
      bbox[base] = x0
      bbox[base + 1] = y0
      bbox[base + 2] = x1
      bbox[base + 3] = y1
    }

    return Encoded(
      inputIds = inputIds,
      attentionMask = attention,
      bbox = bbox,
      tokens = seqTokens,
    )
  }

  private fun imageToTensorData(bitmap: Bitmap?, imageSize: Int): FloatArray {
    val out = FloatArray(3 * imageSize * imageSize) { 0f }
    if (bitmap == null) return out

    val scaled = Bitmap.createScaledBitmap(bitmap, imageSize, imageSize, true)
    val mean = floatArrayOf(0.485f, 0.456f, 0.406f)
    val std = floatArrayOf(0.229f, 0.224f, 0.225f)

    var idxR = 0
    var idxG = imageSize * imageSize
    var idxB = 2 * imageSize * imageSize

    for (y in 0 until imageSize) {
      for (x in 0 until imageSize) {
        val p = scaled.getPixel(x, y)
        val r = Color.red(p) / 255f
        val g = Color.green(p) / 255f
        val b = Color.blue(p) / 255f
        out[idxR++] = (r - mean[0]) / std[0]
        out[idxG++] = (g - mean[1]) / std[1]
        out[idxB++] = (b - mean[2]) / std[2]
      }
    }

    return out
  }

  private data class Entity(val label: String, val text: String, val score: Double)

  private fun decodeEntities(
    logits: Array<Array<FloatArray>>,
    tokens: List<String>,
    labels: Map<Int, String>,
  ): List<Entity> {
    val entities = mutableListOf<Entity>()
    if (logits.isEmpty() || logits[0].isEmpty()) return entities

    val seq = logits[0]
    val limit = min(seq.size, tokens.size)
    for (i in 0 until limit) {
      val probs = softmax(seq[i])
      val (labelId, score) = probs.withIndex().maxByOrNull { it.value }?.let {
        it.index to it.value.toDouble()
      } ?: continue

      val labelRaw = labels[labelId] ?: "O"
      if (labelRaw == "O" || tokens[i].startsWith("[")) continue
      if (score.toDouble() < minimumTokenConfidence) continue
      val label = labelRaw.removePrefix("B-").removePrefix("I-")
      val cleaned = sanitizeEntityToken(tokens[i])
      if (cleaned.isBlank()) continue
      entities += Entity(label = label, text = cleaned, score = score)
    }
    return mergeEntities(entities)
  }

  private fun mergeEntities(entities: List<Entity>): List<Entity> {
    if (entities.isEmpty()) return emptyList()
    val merged = mutableListOf<Entity>()
    var current = entities.first()
    for (i in 1 until entities.size) {
      val next = entities[i]
      if (next.label == current.label) {
        current = current.copy(
          text = "${current.text} ${next.text}".trim(),
          score = max(current.score, next.score),
        )
      } else {
        merged += current
        current = next
      }
    }
    merged += current
    return merged
  }

  private fun entitiesToFields(entities: List<Entity>): Map<String, Any> {
    val fields = mutableMapOf<String, Any>()
    fun add(key: String, value: String) {
      if (value.isBlank() || fields.containsKey(key)) return
      fields[key] = value.trim()
    }

    for (entity in entities) {
      val label = entity.label.lowercase()
      when {
        label.contains("invoice") && label.contains("number") ->
          normalizeIdentifier(entity.text)?.let { add("invoice_number", it) }
        label.contains("receipt") && label.contains("number") ->
          normalizeIdentifier(entity.text)?.let { add("receipt_number", it) }
        label.contains("order") && label.contains("number") ->
          normalizeIdentifier(entity.text)?.let { add("order_number", it) }
        label.contains("po") || (label.contains("purchase") && label.contains("order")) ->
          normalizeIdentifier(entity.text)?.let { add("po_number", it) }
        label.contains("date") -> normalizeDate(entity.text)?.let { add("date_issued", it) }
        label.contains("vendor") && label.contains("name") ->
          normalizeVendorName(entity.text)?.let { add("vendor_name", it) }
        label.contains("total") && label.contains("tax") -> parseAmount(entity.text)?.let { fields["total_tax"] = it }
        label.contains("subtotal") || (label.contains("sub") && label.contains("total")) -> parseAmount(entity.text)?.let { fields["sub_total"] = it }
        label.contains("grand") && label.contains("total") -> parseAmount(entity.text)?.let { fields["grand_total"] = it }
        label.contains("amount") && label.contains("due") -> parseAmount(entity.text)?.let { fields["amount_due"] = it }
      }
    }

    return fields
  }

  private fun parseAmount(raw: String): Double? {
    val n = raw.replace("[^0-9.-]".toRegex(), "").toDoubleOrNull()
    if (n == null || n <= 0.0 || n > 10_000_000.0) return null
    return n
  }

  private fun normalizeIdentifier(raw: String): String? {
    val cleaned = raw.uppercase().replace("[^A-Z0-9\\-/]".toRegex(), "")
    if (cleaned.length !in 2..40) return null
    if (!cleaned.any { it.isDigit() }) return null
    return cleaned
  }

  private fun normalizeDate(raw: String): String? {
    val m = Regex("(\\d{1,4}[/-]\\d{1,2}[/-]\\d{1,4})").find(raw)?.groupValues?.get(1)
    return m
  }

  private fun normalizeVendorName(raw: String): String? {
    val cleaned = raw.replace("[^A-Za-z0-9 &.,'-]".toRegex(), " ").replace("\\s+".toRegex(), " ").trim()
    if (cleaned.length < 3) return null
    val alphaCount = cleaned.count { it.isLetter() }
    if (alphaCount < 3) return null
    return cleaned
  }

  private fun sanitizeEntityToken(raw: String): String {
    return raw.replace("[^A-Za-z0-9$.,:/#&()\\-]".toRegex(), "").trim()
  }

  private fun validateLabelMap(labels: Map<Int, String>) {
    if (labels.isEmpty()) {
      throw IllegalArgumentException("LayoutLMv3 labels are empty")
    }
    val normalized = labels.values.map { it.uppercase() }
    val hasOutside = normalized.any { it == "O" }
    val supportedKeys = listOf("INVOICE", "RECEIPT", "ORDER", "PO", "DATE", "VENDOR", "TOTAL", "DUE")
    val covered = supportedKeys.count { key -> normalized.any { it.contains(key) } }
    if (!hasOutside || covered < 3) {
      throw IllegalArgumentException(
        "LayoutLMv3 labels file appears incompatible. Provide token-classification labels with O/B-/I- tags for invoice entities.",
      )
    }
  }

  private fun softmax(values: FloatArray): FloatArray {
    val maxVal = values.maxOrNull() ?: 0f
    val exps = FloatArray(values.size)
    var sum = 0.0
    for (i in values.indices) {
      val e = kotlin.math.exp((values[i] - maxVal).toDouble())
      exps[i] = e.toFloat()
      sum += e
    }
    if (sum <= 0.0) return FloatArray(values.size) { 0f }
    for (i in exps.indices) exps[i] = (exps[i] / sum.toFloat())
    return exps
  }

  @Suppress("UNCHECKED_CAST")
  private fun extract3DLogits(value: Any): Array<Array<FloatArray>>? {
    return when (value) {
      is Array<*> -> {
        val first = value.firstOrNull() ?: return null
        if (first is Array<*> && first.firstOrNull() is FloatArray) {
          value as Array<Array<FloatArray>>
        } else if (first is FloatArray) {
          arrayOf(value as Array<FloatArray>)
        } else {
          null
        }
      }
      else -> null
    }
  }

  private fun loadLabels(labelsPath: String?): Map<Int, String> {
    if (labelsPath.isNullOrBlank()) return defaultLabels()
    val file = File(labelsPath)
    if (!file.exists()) return defaultLabels()

    val text = file.readText()
    return try {
      val json = JSONObject(text)
      val map = mutableMapOf<Int, String>()
      for (key in json.keys()) {
        val k = key.toIntOrNull() ?: continue
        map[k] = json.optString(key)
      }
      if (map.isEmpty()) defaultLabels() else map
    } catch (_: Exception) {
      file.readLines().mapIndexedNotNull { index, line ->
        val trimmed = line.trim()
        if (trimmed.isEmpty()) null else index to trimmed
      }.toMap().ifEmpty { defaultLabels() }
    }
  }

  private fun loadVocab(modelDir: File?): Map<String, Int> {
    if (modelDir == null) return emptyMap()
    val vocabFile = File(modelDir, "vocab.txt")
    if (!vocabFile.exists()) return emptyMap()
    return vocabFile.readLines().mapIndexedNotNull { index, token ->
      val t = token.trim()
      if (t.isEmpty()) null else t to index
    }.toMap()
  }

  private fun defaultLabels(): Map<Int, String> = mapOf(
    0 to "O",
    1 to "B-INVOICE_NUMBER",
    2 to "I-INVOICE_NUMBER",
    3 to "B-DATE",
    4 to "I-DATE",
    5 to "B-VENDOR_NAME",
    6 to "I-VENDOR_NAME",
    7 to "B-GRAND_TOTAL",
    8 to "I-GRAND_TOTAL",
    9 to "B-AMOUNT_DUE",
    10 to "I-AMOUNT_DUE",
  )

  private fun absStableHash(value: String): Int {
    var hash = 0
    for (ch in value) hash = 31 * hash + ch.code
    return kotlin.math.abs(hash)
  }
}
