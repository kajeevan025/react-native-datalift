// ::: Code Generated by Copilot [f3437c3f-4bec-4e08-9e4d-ecff2f3c0744]. This comment will be removed automatically after the file is saved :::
// ::: Code Generated by Copilot [7c03d4da-36f4-47aa-8a9a-c39f95cfc036]. This comment will be removed automatically after the file is saved :::
import Foundation
import UIKit
import CoreML

// ::: Code Generated by Copilot [f3437c3f-4bec-4e08-9e4d-ecff2f3c0744]. This comment will be removed automatically after the file is saved :::
final class LayoutLMv3OnnxEngine {
    // ::: Code Generated by Copilot [7c03d4da-36f4-47aa-8a9a-c39f95cfc036]. This comment will be removed automatically after the file is saved :::
    private let minimumTokenConfidence = 0.88

    struct Prediction {
        let used: Bool
        let runtime: String
        let confidence: Double
        let fields: [String: Any]
        let warnings: [String]
    }

    private var model: MLModel?
    private var loadedModelPath: String?

    func predict(
        modelPath: String,
        labelsPath: String?,
        text: String,
        image: UIImage?
    ) throws -> Prediction {
        // ::: Code Generated by Copilot [6f1be8ac-d697-4f52-a7c2-7fd074ea8595]. This comment will be removed automatically after the file is saved :::
        guard let labelsPath, !labelsPath.isEmpty else {
            throw NSError(domain: "LayoutLMv3", code: 22, userInfo: [NSLocalizedDescriptionKey: "LayoutLMv3 labels file is required for reliable decoding"])
        }
        guard FileManager.default.fileExists(atPath: labelsPath) else {
            throw NSError(domain: "LayoutLMv3", code: 23, userInfo: [NSLocalizedDescriptionKey: "LayoutLMv3 labels file not found: \(labelsPath)"])
        }

        let labels = loadLabels(labelsPath: labelsPath)
        try validateLabelMap(labels)
        let vocab = loadVocab(modelPath: modelPath)
        let encoded = encode(text: text, vocab: vocab, maxSeqLen: 128)
        let mlModel = try getModel(modelPath: modelPath)
        let featureProvider = try buildFeatureProvider(
            model: mlModel,
            encoded: encoded,
            image: image,
            imageSide: 224
        )
        let output = try mlModel.prediction(from: featureProvider)
        let logits = try readLogits(from: output)
        let entities = decodeEntities(logits: logits, tokens: encoded.tokens, labels: labels)
        let fields = entitiesToFields(entities)
        let confidence = entities.map(\ .score).max() ?? 0
        var warnings: [String] = []
        if entities.isEmpty {
            warnings.append("No high-confidence entities survived post-processing")
        }
        if fields.isEmpty {
            warnings.append("No validated schema fields could be derived from model predictions")
        }

        return Prediction(
            used: !fields.isEmpty,
            runtime: "coreml-ios",
            confidence: confidence,
            fields: fields,
            warnings: warnings
        )
    }

    private func getModel(modelPath: String) throws -> MLModel {
        if let model, loadedModelPath == modelPath { return model }
        let url = URL(fileURLWithPath: modelPath)
        let config = MLModelConfiguration()
        config.computeUnits = .all
        let created = try MLModel(contentsOf: url, configuration: config)
        model = created
        loadedModelPath = modelPath
        return created
    }

    // ::: Code Generated by Copilot [f3437c3f-4bec-4e08-9e4d-ecff2f3c0744]. This comment will be removed automatically after the file is saved :::
    private func buildFeatureProvider(
        model: MLModel,
        encoded: Encoded,
        image: UIImage?,
        imageSide: Int
    ) throws -> MLDictionaryFeatureProvider {
        let inputNames = Set(model.modelDescription.inputDescriptionsByName.keys)

        let ids = try makeMultiArray(shape: [1, 128], data: encoded.inputIds.map(Int32.init))
        let mask = try makeMultiArray(shape: [1, 128], data: encoded.attentionMask.map(Int32.init))
        let bbox = try makeMultiArray(shape: [1, 128, 4], data: encoded.bbox.map(Int32.init))
        let tokenType = try makeMultiArray(shape: [1, 128], data: [Int32](repeating: 0, count: 128))
        let pixel = try makeMultiArray(shape: [1, 3, imageSide as NSNumber, imageSide as NSNumber], data: imageTensor(from: image, side: imageSide))

        var features: [String: MLFeatureValue] = [:]
        if inputNames.contains("input_ids") { features["input_ids"] = MLFeatureValue(multiArray: ids) }
        if inputNames.contains("attention_mask") { features["attention_mask"] = MLFeatureValue(multiArray: mask) }
        if inputNames.contains("bbox") { features["bbox"] = MLFeatureValue(multiArray: bbox) }
        if inputNames.contains("token_type_ids") { features["token_type_ids"] = MLFeatureValue(multiArray: tokenType) }
        if inputNames.contains("pixel_values") { features["pixel_values"] = MLFeatureValue(multiArray: pixel) }

        return try MLDictionaryFeatureProvider(dictionary: features)
    }

    private func makeMultiArray(shape: [NSNumber], data: [Int32]) throws -> MLMultiArray {
        let array = try MLMultiArray(shape: shape, dataType: .int32)
        for (index, value) in data.enumerated() {
            array[index] = NSNumber(value: value)
        }
        return array
    }

    private func makeMultiArray(shape: [NSNumber], data: [Float]) throws -> MLMultiArray {
        let array = try MLMultiArray(shape: shape, dataType: .float32)
        for (index, value) in data.enumerated() {
            array[index] = NSNumber(value: value)
        }
        return array
    }

    private func readLogits(from output: MLFeatureProvider) throws -> [[[Float]]] {
        let logitsFeature = output.featureNames.first { name in
            name.lowercased().contains("logits")
        } ?? output.featureNames.first

        guard let key = logitsFeature,
              let multi = output.featureValue(for: key)?.multiArrayValue else {
            throw NSError(domain: "LayoutLMv3", code: 3, userInfo: [NSLocalizedDescriptionKey: "Model output does not include logits tensor"])
        }

        let shape = multi.shape.map { Int(truncating: $0) }
        guard shape.count == 3 else {
            throw NSError(domain: "LayoutLMv3", code: 4, userInfo: [NSLocalizedDescriptionKey: "Model output must be rank-3 logits [1, seq, labels]"])
        }

        let total = shape.reduce(1, *)
        var arr = Array(repeating: Float(0), count: total)
        for i in 0..<total {
            arr[i] = multi[i].floatValue
        }

        let b = shape[0]
        let s = shape[1]
        let l = shape[2]
        var idx = 0
        var out = Array(repeating: Array(repeating: Array(repeating: Float(0), count: l), count: s), count: b)
        for bi in 0..<b {
            for si in 0..<s {
                for li in 0..<l {
                    out[bi][si][li] = arr[idx]
                    idx += 1
                }
            }
        }
        return out
    }

    private struct Encoded {
        let inputIds: [Int64]
        let attentionMask: [Int64]
        let bbox: [Int64]
        let tokens: [String]
    }

    private func encode(text: String, vocab: [String: Int], maxSeqLen: Int) -> Encoded {
        let words = text.split(whereSeparator: \ .isWhitespace).map(String.init)
        let trimmed = Array(words.prefix(max(0, maxSeqLen - 2)))
        let tokens = ["[CLS]"] + trimmed + ["[SEP]"]

        var ids = Array(repeating: Int64(0), count: maxSeqLen)
        var mask = Array(repeating: Int64(0), count: maxSeqLen)
        var bbox = Array(repeating: Int64(0), count: maxSeqLen * 4)

        for (i, token) in tokens.enumerated() {
            let id: Int64
            if token == "[CLS]" { id = 101 }
            else if token == "[SEP]" { id = 102 }
            else if let v = vocab[token.lowercased()] { id = Int64(v) }
            else { id = Int64(absStableHash(token) % 30000 + 1000) }

            ids[i] = id
            mask[i] = 1

            let y0 = Int64((i * 1000) / max(1, tokens.count))
            let base = i * 4
            bbox[base] = 0
            bbox[base + 1] = y0
            bbox[base + 2] = 1000
            bbox[base + 3] = min(1000, y0 + 10)
        }

        return Encoded(inputIds: ids, attentionMask: mask, bbox: bbox, tokens: tokens)
    }

    private struct Entity {
        let label: String
        let text: String
        let score: Double
    }

    private func decodeEntities(logits: [[[Float]]], tokens: [String], labels: [Int: String]) -> [Entity] {
        guard let seq = logits.first else { return [] }
        let limit = min(seq.count, tokens.count)
        var entities: [Entity] = []

        for i in 0..<limit {
            let probs = softmax(seq[i])
            guard let best = probs.enumerated().max(by: { $0.element < $1.element }) else { continue }
            let labelRaw = labels[best.offset] ?? "O"
            if labelRaw == "O" || tokens[i].hasPrefix("[") { continue }
            if Double(best.element) < minimumTokenConfidence { continue }
            let label = labelRaw.replacingOccurrences(of: "B-", with: "").replacingOccurrences(of: "I-", with: "")
            let cleaned = sanitizeEntityToken(tokens[i])
            if cleaned.isEmpty { continue }
            entities.append(Entity(label: label, text: cleaned, score: Double(best.element)))
        }

        return mergeEntities(entities)
    }

    private func mergeEntities(_ entities: [Entity]) -> [Entity] {
        guard var current = entities.first else { return [] }
        var merged: [Entity] = []
        for e in entities.dropFirst() {
            if e.label == current.label {
                current = Entity(label: current.label, text: "\(current.text) \(e.text)", score: max(current.score, e.score))
            } else {
                merged.append(current)
                current = e
            }
        }
        merged.append(current)
        return merged
    }

    private func entitiesToFields(_ entities: [Entity]) -> [String: Any] {
        var fields: [String: Any] = [:]

        for e in entities {
            let label = e.label.lowercased()
            if label.contains("invoice") && label.contains("number") {
                if let value = normalizeIdentifier(e.text) {
                    fields["invoice_number"] = fields["invoice_number"] ?? value
                }
            } else if label.contains("receipt") && label.contains("number") {
                if let value = normalizeIdentifier(e.text) {
                    fields["receipt_number"] = fields["receipt_number"] ?? value
                }
            } else if label.contains("order") && label.contains("number") {
                if let value = normalizeIdentifier(e.text) {
                    fields["order_number"] = fields["order_number"] ?? value
                }
            } else if label.contains("po") || (label.contains("purchase") && label.contains("order")) {
                if let value = normalizeIdentifier(e.text) {
                    fields["po_number"] = fields["po_number"] ?? value
                }
            } else if label.contains("date") {
                if let value = normalizeDate(e.text) {
                    fields["date_issued"] = fields["date_issued"] ?? value
                }
            } else if label.contains("vendor") && label.contains("name") {
                if let value = normalizeVendorName(e.text) {
                    fields["vendor_name"] = fields["vendor_name"] ?? value
                }
            } else if label.contains("grand") && label.contains("total") {
                if let amount = parseAmount(e.text) { fields["grand_total"] = fields["grand_total"] ?? amount }
            } else if label.contains("amount") && label.contains("due") {
                if let amount = parseAmount(e.text) { fields["amount_due"] = fields["amount_due"] ?? amount }
            }
        }

        return fields
    }

    private func parseAmount(_ raw: String) -> Double? {
        let cleaned = raw.replacingOccurrences(of: "[^0-9.-]", with: "", options: .regularExpression)
        guard let value = Double(cleaned), value > 0, value <= 10_000_000 else {
            return nil
        }
        return value
    }

    private func normalizeIdentifier(_ raw: String) -> String? {
        let cleaned = raw.uppercased().replacingOccurrences(of: "[^A-Z0-9\\-/]", with: "", options: .regularExpression)
        guard cleaned.count >= 2, cleaned.count <= 40 else { return nil }
        guard cleaned.contains(where: { $0.isNumber }) else { return nil }
        return cleaned
    }

    private func normalizeDate(_ raw: String) -> String? {
        guard let rx = try? NSRegularExpression(pattern: "(\\d{1,4}[/-]\\d{1,2}[/-]\\d{1,4})") else {
            return nil
        }
        let ns = raw as NSString
        guard let match = rx.firstMatch(in: raw, range: NSRange(location: 0, length: ns.length)) else {
            return nil
        }
        return ns.substring(with: match.range(at: 1))
    }

    private func normalizeVendorName(_ raw: String) -> String? {
        let cleaned = raw.replacingOccurrences(of: "[^A-Za-z0-9 &.,'-]", with: " ", options: .regularExpression)
            .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)
        guard cleaned.count >= 3 else { return nil }
        let letters = cleaned.filter { $0.isLetter }.count
        guard letters >= 3 else { return nil }
        return cleaned
    }

    private func sanitizeEntityToken(_ raw: String) -> String {
        return raw.replacingOccurrences(of: "[^A-Za-z0-9$.,:/#&()\\-]", with: "", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private func validateLabelMap(_ labels: [Int: String]) throws {
        guard !labels.isEmpty else {
            throw NSError(domain: "LayoutLMv3", code: 20, userInfo: [NSLocalizedDescriptionKey: "LayoutLMv3 labels are empty"])
        }

        let normalized = labels.values.map { $0.uppercased() }
        let hasOutside = normalized.contains("O")
        let expectedKeys = ["INVOICE", "RECEIPT", "ORDER", "PO", "DATE", "VENDOR", "TOTAL", "DUE"]
        let coverage = expectedKeys.filter { key in normalized.contains(where: { $0.contains(key) }) }.count

        guard hasOutside, coverage >= 3 else {
            throw NSError(
                domain: "LayoutLMv3",
                code: 21,
                userInfo: [
                    NSLocalizedDescriptionKey: "LayoutLMv3 labels file appears incompatible. Provide token-classification labels with O/B-/I- tags for invoice entities."
                ]
            )
        }
    }

    private func imageTensor(from image: UIImage?, side: Int) -> [Float] {
        let count = 3 * side * side
        guard let image else { return Array(repeating: 0, count: count) }
        UIGraphicsBeginImageContextWithOptions(CGSize(width: side, height: side), true, 1)
        image.draw(in: CGRect(x: 0, y: 0, width: side, height: side))
        guard let scaled = UIGraphicsGetImageFromCurrentImageContext(),
              let cg = scaled.cgImage,
              let provider = cg.dataProvider,
              let raw = provider.data else {
            UIGraphicsEndImageContext()
            return Array(repeating: 0, count: count)
        }
        UIGraphicsEndImageContext()

        let ptr = CFDataGetBytePtr(raw)
        let bytesPerPixel = 4
        var out = Array(repeating: Float(0), count: count)
        let mean: [Float] = [0.485, 0.456, 0.406]
        let std: [Float] = [0.229, 0.224, 0.225]

        var rIdx = 0
        var gIdx = side * side
        var bIdx = 2 * side * side

        for y in 0..<side {
            for x in 0..<side {
                let offset = (y * side + x) * bytesPerPixel
                let r = Float(ptr?[offset] ?? 0) / 255.0
                let g = Float(ptr?[offset + 1] ?? 0) / 255.0
                let b = Float(ptr?[offset + 2] ?? 0) / 255.0

                out[rIdx] = (r - mean[0]) / std[0]
                out[gIdx] = (g - mean[1]) / std[1]
                out[bIdx] = (b - mean[2]) / std[2]
                rIdx += 1
                gIdx += 1
                bIdx += 1
            }
        }

        return out
    }

    private func loadLabels(labelsPath: String?) -> [Int: String] {
        guard let labelsPath,
              FileManager.default.fileExists(atPath: labelsPath),
              let data = try? Data(contentsOf: URL(fileURLWithPath: labelsPath)) else {
            return defaultLabels()
        }

        if let dict = try? JSONSerialization.jsonObject(with: data) as? [String: String] {
            var out: [Int: String] = [:]
            for (k, v) in dict {
                if let id = Int(k) { out[id] = v }
            }
            return out.isEmpty ? defaultLabels() : out
        }

        if let text = String(data: data, encoding: .utf8) {
            let lines = text.split(separator: "\n").map { String($0).trimmingCharacters(in: .whitespacesAndNewlines) }.filter { !$0.isEmpty }
            if !lines.isEmpty {
                return Dictionary(uniqueKeysWithValues: lines.enumerated().map { ($0.offset, $0.element) })
            }
        }

        return defaultLabels()
    }

    private func loadVocab(modelPath: String) -> [String: Int] {
        let modelURL = URL(fileURLWithPath: modelPath)
        let vocabURL = modelURL.deletingLastPathComponent().appendingPathComponent("vocab.txt")
        guard let text = try? String(contentsOf: vocabURL, encoding: .utf8) else { return [:] }
        let lines = text.split(separator: "\n").map(String.init)
        var out: [String: Int] = [:]
        for (i, token) in lines.enumerated() {
            let t = token.trimmingCharacters(in: .whitespacesAndNewlines)
            if !t.isEmpty { out[t] = i }
        }
        return out
    }

    private func softmax(_ values: [Float]) -> [Float] {
        guard let maxVal = values.max() else { return [] }
        let exps = values.map { Foundation.exp(Double($0 - maxVal)) }
        let sum = exps.reduce(0, +)
        guard sum > 0 else { return Array(repeating: 0, count: values.count) }
        return exps.map { Float($0 / sum) }
    }

    private func defaultLabels() -> [Int: String] {
        return [
            0: "O",
            1: "B-INVOICE_NUMBER",
            2: "I-INVOICE_NUMBER",
            3: "B-DATE",
            4: "I-DATE",
            5: "B-VENDOR_NAME",
            6: "I-VENDOR_NAME",
            7: "B-GRAND_TOTAL",
            8: "I-GRAND_TOTAL",
            9: "B-AMOUNT_DUE",
            10: "I-AMOUNT_DUE",
        ]
    }

    private func absStableHash(_ value: String) -> Int {
        var hash = 0
        for scalar in value.unicodeScalars {
            hash = 31 &* hash &+ Int(scalar.value)
        }
        return Swift.abs(hash)
    }
}

private extension Data {
    init<T>(from array: [T]) {
        self = array.withUnsafeBufferPointer { Data(buffer: $0) }
    }
}
