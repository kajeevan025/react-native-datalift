// ::: Code Generated by Copilot [7e6d4f2a-3c6e-4f58-98e5-7b0ad97d40f1]. This comment will be removed automatically after the file is saved :::
import Foundation
import UIKit
import React

/**
 * DataLift native module for iOS.
 *
 * Provides native OCR (Apple Vision), document classification,
 * and PDF page extraction to the React Native JavaScript layer.
 * Compatible with React Native 0.70+ (both old and new architecture)
 */
@objc(DataLift)
class DataLiftModule: NSObject, RCTBridgeModule {

    // Required for RCTBridgeModule protocol
    static func moduleName() -> String! {
        return "DataLift"
    }
    
    private let ocrEngine = OCREngine()
    private let classifier = DocumentClassifier()
    // ::: Code Generated by Copilot [9f9f85db-278e-4f9e-b4f0-58d0da429d5f]. This comment will be removed automatically after the file is saved :::
    private let layoutLMv3OnnxEngine = LayoutLMv3OnnxEngine()
    // ::: Code Generated by Copilot [f8190b85-d1ac-4418-9162-86ee5609e355]. This comment will be removed automatically after the file is saved :::
    private var layoutLMv3ModelPath: String?
    private var layoutLMv3LabelsPath: String?

    // ::: Code Generated by Copilot [08eba1d9-3f70-4911-9596-c770668f8049]. This comment will be removed automatically after the file is saved :::
    private func resolveModelPath(_ modelPathOverride: String?) throws -> String {
        let trimmedOverride = modelPathOverride?.trimmingCharacters(in: .whitespacesAndNewlines)
        let resolvedModelPath = (trimmedOverride?.isEmpty == false)
            ? filePathFromUri(trimmedOverride!)
            : layoutLMv3ModelPath
        guard let modelPath = resolvedModelPath, !modelPath.isEmpty else {
            throw DataLiftError.invalidInput("LayoutLMv3 model is not configured. Call configureLayoutLMv3 first.")
        }
        return modelPath
    }

    // ::: Code Generated by Copilot [08eba1d9-3f70-4911-9596-c770668f8049]. This comment will be removed automatically after the file is saved :::
    private func resolveLabelsPath(_ labelsPathOverride: String?) throws -> String {
        let trimmedOverride = labelsPathOverride?.trimmingCharacters(in: .whitespacesAndNewlines)
        let resolvedLabelsPath = (trimmedOverride?.isEmpty == false)
            ? filePathFromUri(trimmedOverride!)
            : layoutLMv3LabelsPath
        guard let labelsPath = resolvedLabelsPath, !labelsPath.isEmpty else {
            throw DataLiftError.invalidInput("LayoutLMv3 labels file is required. Provide labels_path.")
        }
        return labelsPath
    }

    // ::: Code Generated by Copilot [17dd0bc5-c94b-4d7b-a787-f3a68eff06f4]. This comment will be removed automatically after the file is saved :::
    private struct LayoutPredictionResult {
        let used: Bool
        let runtime: String
        let modelPath: String
        let confidence: Double
        let fields: [String: Any]
        let warnings: [String]
    }

    @objc
    static func requiresMainQueueSetup() -> Bool {
        return false
    }
    
    // MARK: - Helper Methods
    
    /**
     * Convert file:// URI to proper file path
     * Handles both file:// URIs and regular file paths
     */
    private func filePathFromUri(_ uri: String) -> String {
        if uri.hasPrefix("file://") {
            // Remove file:// scheme and decode percent-encoding
            let path = uri.replacingOccurrences(of: "file://", with: "")
            return path.removingPercentEncoding ?? path
        }
        return uri
    }
    
    /**
     * Load UIImage from file:// URI or file path
     */
    private func loadImage(from uri: String) throws -> UIImage {
        let filePath = filePathFromUri(uri)
        
        // Check if file exists first
        let fileManager = FileManager.default
        guard fileManager.fileExists(atPath: filePath) else {
            // Try without file:// prefix if present
            let alternativePath = uri.hasPrefix("file://") ? String(uri.dropFirst(7)) : uri
            if fileManager.fileExists(atPath: alternativePath), let image = UIImage(contentsOfFile: alternativePath) {
                return image
            }
            throw DataLiftError.invalidInput("File does not exist at: \(filePath) (original URI: \(uri))")
        }
        
        // Try loading with Data first (most reliable)
        if let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)),
           let image = UIImage(data: data) {
            return image
        }
        
        // Fallback to contentsOfFile
        if let image = UIImage(contentsOfFile: filePath) {
            return image
        }
        
        throw DataLiftError.invalidInput("Failed to decode image data at: \(uri)")
    }

    // MARK: - classifyDocument

    /**
     * Classify a document image by type.
     *
     * - Parameter options: Dictionary with "uri" (String) and optional "text" (String)
     * - Parameter resolve: Promise resolve callback with { type: String, confidence: Double }
     * - Parameter reject: Promise reject callback
     */
    @objc
    func classifyDocument(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }

            do {
                guard let imageUri = options["uri"] as? String else {
                    throw DataLiftError.invalidInput("Image URI is required")
                }

                let text = options["text"] as? String ?? ""
                let image = try self.loadImage(from: imageUri)
                let result = self.classifier.classify(image: image, text: text)

                resolve([
                    "type": result.type,
                    "confidence": result.confidence
                ])
            } catch let error as DataLiftError {
                reject(error.code, error.message, error)
            } catch {
                reject("CLASSIFICATION_ERROR", error.localizedDescription, error)
            }
        }
    }

    // MARK: - extractTextNative

    /**
     * Extract text from an image using Apple Vision framework.
     *
     * - Parameter options: Dictionary with "uri" (String) and optional "language" (String)
     * - Parameter resolve: Promise resolve callback with { text: String, lineCount: Int, confidence: Float }
     * - Parameter reject: Promise reject callback
     */
    @objc
    func extractTextNative(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }

            do {
                guard let imageUri = options["uri"] as? String else {
                    throw DataLiftError.invalidInput("Image URI is required")
                }

                let image = try self.loadImage(from: imageUri)
                let language = options["language"] as? String ?? "en"
                let result = try self.ocrEngine.extractText(from: image, language: language)

                resolve([
                    "text": result.text,
                    "lineCount": result.text.split(separator: "\n").count,
                    "confidence": result.confidence
                ])
            } catch let error as DataLiftError {
                reject(error.code, error.message, error)
            } catch {
                reject("OCR_ERROR", error.localizedDescription, error)
            }
        }
    }

    // MARK: - extractPDFPages

    /**
     * Extract specific pages from a PDF as images.
     *
     * - Parameter options: Dictionary with "uri" (String) and optional "pages" ([Int])
     * - Parameter resolve: Promise resolve callback with array of { uri: String }
     * - Parameter reject: Promise reject callback
     */
    @objc
    func extractPDFPages(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async {
            do {
                guard let pdfUri = options["uri"] as? String else {
                    throw DataLiftError.invalidInput("PDF URI is required")
                }

                let pagesArray = options["pages"] as? [Int] ?? [0]
                let pdfURL = URL(fileURLWithPath: pdfUri)

                guard let document = CGPDFDocument(pdfURL as CFURL) else {
                    throw DataLiftError.invalidInput("Failed to open PDF at: \(pdfUri)")
                }

                var results: [[String: Any]] = []
                let tempDir = NSTemporaryDirectory()

                for pageIndex in pagesArray {
                    // CGPDFDocument pages are 1-indexed
                    let pdfPageIndex = pageIndex + 1
                    guard pdfPageIndex > 0, pdfPageIndex <= document.numberOfPages,
                          let page = document.page(at: pdfPageIndex) else {
                        continue
                    }

                    let pageRect = page.getBoxRect(.mediaBox)
                    let scale: CGFloat = 3.0 // ~300 DPI for letter-size

                    let renderer = UIGraphicsImageRenderer(
                        size: CGSize(
                            width: pageRect.width * scale,
                            height: pageRect.height * scale
                        )
                    )

                    let image = renderer.image { context in
                        let cgContext = context.cgContext
                        cgContext.setFillColor(UIColor.white.cgColor)
                        cgContext.fill(CGRect(
                            origin: .zero,
                            size: CGSize(
                                width: pageRect.width * scale,
                                height: pageRect.height * scale
                            )
                        ))
                        cgContext.translateBy(x: 0, y: pageRect.height * scale)
                        cgContext.scaleBy(x: scale, y: -scale)
                        cgContext.drawPDFPage(page)
                    }

                    let fileName = "datalift_page_\(pageIndex)_\(Int(Date().timeIntervalSince1970)).png"
                    let filePath = (tempDir as NSString).appendingPathComponent(fileName)

                    if let data = image.pngData() {
                        try data.write(to: URL(fileURLWithPath: filePath))
                        results.append(["uri": filePath])
                    }
                }

                resolve(results)
            } catch let error as DataLiftError {
                reject(error.code, error.message, error)
            } catch {
                reject("PDF_ERROR", error.localizedDescription, error)
            }
        }
    }

    // ::: Code Generated by Copilot [c4ab5f23-286b-45ef-9167-776c6fd1d8ec]. This comment will be removed automatically after the file is saved :::
    // MARK: - extractInvoiceSchema

    /**
     * Extract invoice-style schema JSON from an image.
     *
     * - Parameter options: Dictionary with "uri" (String) and optional "language" (String)
     * - Parameter resolve: Promise resolve callback with schema JSON object
     * - Parameter reject: Promise reject callback
     */
    @objc
    func extractInvoiceSchema(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }

            do {
                let singleUri = options["uri"] as? String
                let uriList = options["uris"] as? [String]
                let uris = (uriList?.isEmpty == false ? uriList! : (singleUri != nil ? [singleUri!] : []))
                guard !uris.isEmpty else {
                    throw DataLiftError.invalidInput("Image URI is required")
                }

                let language = options["language"] as? String ?? "en"
                let providedFileNames = options["file_names"] as? [String] ?? []

                var allTextParts: [String] = []
                var pageConfidences: [Double] = []
                var firstImage: UIImage?

                for uri in uris {
                    let image = try self.loadImage(from: uri)
                    if firstImage == nil { firstImage = image }
                    let ocrResult = try self.ocrEngine.extractText(from: image, language: language)
                    allTextParts.append(ocrResult.text)
                    pageConfidences.append(Double(ocrResult.confidence))
                }

                let mergedText = allTextParts.joined(separator: "\n")
                let avgConfidence = pageConfidences.isEmpty
                    ? 0.0
                    : pageConfidences.reduce(0.0, +) / Double(pageConfidences.count)

                let requireModelPrediction: Bool = {
                    if let value = options["require_model_prediction"] as? Bool {
                        return value
                    }
                    return true
                }()

                let prediction = try self.predictLayoutLMv3Internal(
                    rawText: mergedText,
                    modelPathOverride: options["model_path"] as? String,
                    labelsPathOverride: options["labels_path"] as? String,
                    image: firstImage
                )

                if requireModelPrediction && !prediction.used {
                    throw DataLiftError.invalidInput(
                        "LayoutLMv3 prediction produced no fields; native extraction aborted"
                    )
                }

                let schema = self.buildSchemaFromModelPrediction(
                    text: mergedText,
                    uris: uris,
                    fileNames: providedFileNames,
                    language: language,
                    ocrConfidence: avgConfidence,
                    prediction: prediction
                )

                resolve(schema)
            } catch let error as DataLiftError {
                reject(error.code, error.message, error)
            } catch {
                reject("INVOICE_SCHEMA_ERROR", error.localizedDescription, error)
            }
        }
    }

    // ::: Code Generated by Copilot [f8190b85-d1ac-4418-9162-86ee5609e355]. This comment will be removed automatically after the file is saved :::
    @objc
    func configureLayoutLMv3(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            do {
                guard let modelPath = options["model_path"] as? String, !modelPath.isEmpty else {
                    throw DataLiftError.invalidInput("'model_path' is required for LayoutLMv3")
                }
                let resolvedModelPath = self.filePathFromUri(modelPath)
                guard FileManager.default.fileExists(atPath: resolvedModelPath) else {
                    throw DataLiftError.invalidInput("LayoutLMv3 model not found at path: \(resolvedModelPath)")
                }

                let labelsPath = (options["labels_path"] as? String)?.trimmingCharacters(in: .whitespacesAndNewlines)
                if let labelsPath, !labelsPath.isEmpty {
                    let resolvedLabelsPath = self.filePathFromUri(labelsPath)
                    guard FileManager.default.fileExists(atPath: resolvedLabelsPath) else {
                        throw DataLiftError.invalidInput("LayoutLMv3 labels file not found at path: \(resolvedLabelsPath)")
                    }
                    self.layoutLMv3LabelsPath = resolvedLabelsPath
                }

                self.layoutLMv3ModelPath = resolvedModelPath

                resolve([
                    "configured": true,
                    "model_path": resolvedModelPath
                ])
            } catch let error as DataLiftError {
                reject(error.code, error.message, error)
            } catch {
                reject("LAYOUTLMV3_CONFIG_ERROR", error.localizedDescription, error)
            }
        }
    }

    // ::: Code Generated by Copilot [f8190b85-d1ac-4418-9162-86ee5609e355]. This comment will be removed automatically after the file is saved :::
    @objc
    func predictLayoutLMv3(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            do {
                let rawText = options["raw_text"] as? String ?? ""
                let prediction = try self.predictLayoutLMv3Internal(
                    rawText: rawText,
                    modelPathOverride: options["model_path"] as? String,
                    labelsPathOverride: options["labels_path"] as? String,
                    image: nil
                )

                resolve([
                    "used": prediction.used,
                    "runtime": prediction.runtime,
                    "model_path": prediction.modelPath,
                    "confidence": prediction.confidence,
                    "fields": prediction.fields,
                    "warnings": prediction.warnings
                ])
            } catch let error as DataLiftError {
                reject(error.code, error.message, error)
            } catch {
                reject("LAYOUTLMV3_PREDICT_ERROR", error.localizedDescription, error)
            }
        }
    }

    // ::: Code Generated by Copilot [08eba1d9-3f70-4911-9596-c770668f8049]. This comment will be removed automatically after the file is saved :::
    @objc
    func checkLayoutLMv3Compatibility(
        _ options: NSDictionary,
        resolve: @escaping RCTPromiseResolveBlock,
        reject: @escaping RCTPromiseRejectBlock
    ) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }

            var checks: [String: Any] = [
                "model_file": false,
                "labels_file": false,
                "label_map": false,
                "inference": false,
            ]

            do {
                let modelPath = try self.resolveModelPath(options["model_path"] as? String)
                let labelsPath = try self.resolveLabelsPath(options["labels_path"] as? String)

                let modelExists = FileManager.default.fileExists(atPath: modelPath)
                let labelsExists = FileManager.default.fileExists(atPath: labelsPath)
                checks["model_file"] = modelExists
                checks["labels_file"] = labelsExists

                guard modelExists else {
                    throw DataLiftError.invalidInput("LayoutLMv3 model not found at path: \(modelPath)")
                }
                guard labelsExists else {
                    throw DataLiftError.invalidInput("LayoutLMv3 labels file not found at path: \(labelsPath)")
                }

                let prediction = try self.predictLayoutLMv3Internal(
                    rawText: "invoice number INV-1001 date 2026-01-01 total 123.45 vendor acme",
                    modelPathOverride: modelPath,
                    labelsPathOverride: labelsPath,
                    image: nil
                )

                checks["label_map"] = true
                checks["inference"] = true

                var warnings = prediction.warnings
                if !prediction.used {
                    warnings.append("Compatibility passed but sample probe did not produce mapped fields")
                }

                resolve([
                    "compatible": true,
                    "runtime": prediction.runtime,
                    "model_path": modelPath,
                    "labels_path": labelsPath,
                    "checks": checks,
                    "warnings": warnings,
                ])
            } catch {
                resolve([
                    "compatible": false,
                    "checks": checks,
                    "warnings": [],
                    "error": error.localizedDescription,
                ])
            }
        }
    }

    // ::: Code Generated by Copilot [17dd0bc5-c94b-4d7b-a787-f3a68eff06f4]. This comment will be removed automatically after the file is saved :::
    private func predictLayoutLMv3Internal(
        rawText: String,
        modelPathOverride: String?,
        labelsPathOverride: String?,
        image: UIImage?
    ) throws -> LayoutPredictionResult {
        let modelPath = try resolveModelPath(modelPathOverride)
        guard FileManager.default.fileExists(atPath: modelPath) else {
            throw DataLiftError.invalidInput("Configured LayoutLMv3 model path does not exist: \(modelPath)")
        }

        let labelsPath = try resolveLabelsPath(labelsPathOverride)
        guard FileManager.default.fileExists(atPath: labelsPath) else {
            throw DataLiftError.invalidInput("LayoutLMv3 labels file not found at path: \(labelsPath)")
        }
        layoutLMv3LabelsPath = labelsPath

        // ::: Code Generated by Copilot [9f9f85db-278e-4f9e-b4f0-58d0da429d5f]. This comment will be removed automatically after the file is saved :::
        let onnxPrediction = try layoutLMv3OnnxEngine.predict(
            modelPath: modelPath,
            labelsPath: labelsPath,
            text: rawText,
            image: image
        )

        return LayoutPredictionResult(
            used: onnxPrediction.used,
            runtime: onnxPrediction.runtime,
            modelPath: modelPath,
            confidence: onnxPrediction.confidence,
            fields: onnxPrediction.fields,
            warnings: onnxPrediction.warnings
        )
    }

    // ::: Code Generated by Copilot [17dd0bc5-c94b-4d7b-a787-f3a68eff06f4]. This comment will be removed automatically after the file is saved :::
    private func buildSchemaFromModelPrediction(
        text: String,
        uris: [String],
        fileNames: [String],
        language: String,
        ocrConfidence: Double,
        prediction: LayoutPredictionResult
    ) -> [String: Any] {
        let invoiceNumber = prediction.fields["invoice_number"] as? String
        let receiptNumber = prediction.fields["receipt_number"] as? String
        let poNumber = prediction.fields["po_number"] as? String
        let orderNumber = prediction.fields["order_number"] as? String
        let dateIssued = prediction.fields["date_issued"] as? String

        let subTotal = (prediction.fields["sub_total"] as? NSNumber)?.doubleValue
        let totalTax = (prediction.fields["total_tax"] as? NSNumber)?.doubleValue
        let grandTotal = (prediction.fields["grand_total"] as? NSNumber)?.doubleValue
        let amountPaid = (prediction.fields["amount_paid"] as? NSNumber)?.doubleValue
        let amountDue = (prediction.fields["amount_due"] as? NSNumber)?.doubleValue

        let documentType = detectDocumentType(
            text: text,
            hasInvoiceNumber: invoiceNumber != nil,
            hasReceiptNumber: receiptNumber != nil
        )
        let currency = detectCurrency(in: text)

        let imagesPayload: [[String: Any]] = uris.enumerated().map { index, uri in
            let fileName: String
            if index < fileNames.count, !fileNames[index].isEmpty {
                fileName = fileNames[index]
            } else {
                fileName = URL(fileURLWithPath: filePathFromUri(uri)).lastPathComponent
            }
            return [
                "image_id": "img_\(String(format: "%03d", index + 1))",
                "file_name": fileName,
                "page_index": index
            ]
        }

        var totals: [String: Any] = [:]
        if let subTotal { totals["sub_total"] = subTotal }
        if let totalTax { totals["total_tax"] = totalTax }
        if let grandTotal { totals["grand_total"] = grandTotal }
        if let amountPaid { totals["amount_paid"] = amountPaid }
        if let amountDue { totals["amount_due"] = amountDue }

        var modelPayload: [String: Any] = [
            "layoutlmv3_used": prediction.used,
            "layoutlmv3_source": "native",
            "layoutlmv3_runtime": prediction.runtime,
            "layoutlmv3_model": prediction.modelPath,
        ]
        if let labelsPath = layoutLMv3LabelsPath, !labelsPath.isEmpty {
            modelPayload["layoutlmv3_labels"] = labelsPath
        }

        return [
            "document_id": UUID().uuidString.lowercased(),
            "document_type": documentType,
            "locale": "\(language)-US",
            "currency": currency,
            "images": imagesPayload,
            "header": [
                "invoice_number": ns(invoiceNumber),
                "receipt_number": ns(receiptNumber),
                "po_number": ns(poNumber),
                "order_number": ns(orderNumber),
                "date_issued": ns(dateIssued),
                "page": uris.count,
                "total_pages": uris.count
            ],
            "vendor": [
                "name": ns(prediction.fields["vendor_name"] as? String)
            ],
            "totals": totals,
            "metadata": [
                "raw_text": text
            ],
            "audit": [
                "ocr_engine": "vision",
                "extraction_timestamp": ISO8601DateFormatter().string(from: Date()),
                "confidence": [
                    "ocr": ocrConfidence,
                    "layoutlmv3.offline": prediction.confidence
                ],
                "warnings": prediction.warnings,
                "model": modelPayload
            ]
        ]
    }

    // MARK: - Invoice schema helpers

    // ::: Code Generated by Copilot [c4ab5f23-286b-45ef-9167-776c6fd1d8ec]. This comment will be removed automatically after the file is saved :::
    private func buildUnifiedSchema(
        text: String,
        uris: [String],
        fileNames: [String],
        images: [UIImage],
        language: String,
        ocrConfidence: Double,
        pageConfidences: [Double]
    ) -> [String: Any] {
        let lines = text
            .split(separator: "\n")
            .map { String($0).trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }

        let invoiceNumber = firstMatch(in: text, pattern: "(?:invoice\\s*(?:no\\.?|#|number)?|inv\\s*[#:])\\s*([A-Z0-9][A-Z0-9\\-\\/]{1,30})")
        let receiptNumber = firstMatch(in: text, pattern: "(?:receipt\\s*(?:no\\.?|#|number)?|rcpt\\s*[#:])\\s*([A-Z0-9][A-Z0-9\\-\\/]{1,30})")
        let poNumber = firstMatch(in: text, pattern: "(?:purchase\\s*order|p\\.?o\\.?)\\s*(?:no\\.?|#|number)?\\s*[:\\-]?\\s*([A-Z0-9][A-Z0-9\\-\\/]{1,30})")
        let orderNumber = firstMatch(in: text, pattern: "(?:order\\s*(?:no\\.?|#|number)?)\\s*[:\\-]?\\s*([A-Z0-9][A-Z0-9\\-\\/]{1,30})")
        let dateIssued = normaliseDate(firstMatch(in: text, pattern: "(?:invoice\\s*date|receipt\\s*date|date)\\s*[:\\-]?\\s*([0-9]{1,4}[\\/\\-][0-9]{1,2}[\\/\\-][0-9]{2,4})"))
        let timeIssued = normaliseTime(firstMatch(in: text, pattern: "\\b([0-9]{1,2}:[0-9]{2}(?::[0-9]{2})?)\\b"))

        let docType = detectDocumentType(text: text, hasInvoiceNumber: invoiceNumber != nil, hasReceiptNumber: receiptNumber != nil)
        let currency = detectCurrency(in: text)

        // ::: Code Generated by Copilot [d8a1e4f7-9b3c-42d5-a6e8-1f2d3c4b5a69]. This comment will be removed automatically after the file is saved :::
        let vendorName = extractVendorName(lines: lines)
        let vendorBranch = extractBranch(lines: lines)
        let vendorEmail = firstMatch(in: text, pattern: "([A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,})")
        let vendorPhone = firstMatch(in: text, pattern: "(?:\\+?\\d[\\d\\s\\-()]{6,}\\d)")
        let vendorWebsite = firstMatch(in: text, pattern: "((?:https?://|www\\.)[^\\s]+)")
        let vendorTaxId = firstMatch(in: text, pattern: "(?:tax\\s*id|tin|ein|vat)\\s*[:\\-]?\\s*([A-Z0-9\\-]{5,30})")
        let vendorAddressLines = extractVendorAddressLines(lines: lines)
        let customerId = extractCustomerId(text: text)

        let buyer = extractBuyer(lines: lines)
        let rawItems = extractLineItems(lines: lines)
        let lineItems = mapUnifiedLineItems(rawItems)
        let remittanceData = extractRemittance(text: text)

        // Card brand detection
        var cardBrand: String?
        let brandPatterns: [(String, String)] = [("mastercard", "Mastercard"), ("visa", "Visa"), ("american express", "American Express"), ("discover", "Discover")]
        for (search, name) in brandPatterns {
            if text.lowercased().contains(search) { cardBrand = name; break }
        }

        let subTotal = firstAmount(in: text, labels: ["sub total", "subtotal"]) ?? lineItems.reduce(0.0) { $0 + (($1["extended_price"] as? Double) ?? 0.0) }
        let totalTax = firstAmount(in: text, labels: ["total tax", "tax total", "tax", "vat", "gst"]) ?? 0.0
        let discountTotal = firstAmount(in: text, labels: ["discount total", "discount"]) ?? 0.0
        let shippingTotal = firstAmount(in: text, labels: ["shipping total", "shipping", "delivery", "freight"]) ?? 0.0
        let grandTotal = firstAmount(in: text, labels: ["grand total", "total amount due", "amount due", "total"]) ?? (subTotal + totalTax + shippingTotal - discountTotal)
        let amountPaid = firstAmount(in: text, labels: ["amount paid", "paid", "tendered"])
        let amountDue = firstAmount(in: text, labels: ["amount due", "balance due"]) ?? max(0, grandTotal - (amountPaid ?? 0))

        let paymentMethod = firstMatch(in: text, pattern: "(?:payment\\s*(?:method|mode)|paid\\s*by|tender|card)\\s*[:\\-]?\\s*([A-Za-z][A-Za-z\\s]{2,40})")
        let maskedAccount = firstMatch(in: text, pattern: "([xX*]{4,}\\d{2,4})")
        let authCode = firstMatch(in: text, pattern: "(?:auth(?:orization)?\\s*code|approval)\\s*[:\\-]?\\s*([A-Z0-9]{4,20})")
        let aid = firstMatch(in: text, pattern: "\\b(A[0-9A-F]{8,32})\\b")
        let cryptogram = firstMatch(in: text, pattern: "(?:cryptogram|tc)\\s*[:\\-]?\\s*([A-Z0-9]{8,64})")

        let imagesPayload: [[String: Any]] = uris.enumerated().map { index, uri in
            let fileName: String
            if index < fileNames.count, !fileNames[index].isEmpty {
                fileName = fileNames[index]
            } else {
                fileName = URL(fileURLWithPath: filePathFromUri(uri)).lastPathComponent
            }
            return [
                "image_id": "img_\(String(format: "%03d", index + 1))",
                "file_name": fileName,
                "page_index": index
            ]
        }

        var confidenceMap: [String: Any] = [:]
        let baseConfidence = rounded(ocrConfidence, digits: 2)
        if invoiceNumber != nil { confidenceMap["header.invoice_number"] = baseConfidence }
        if receiptNumber != nil { confidenceMap["header.receipt_number"] = baseConfidence }
        confidenceMap["totals.grand_total"] = baseConfidence
        if !lineItems.isEmpty { confidenceMap["line_items.0.description"] = max(0.65, baseConfidence - 0.08) }

        let warnings = lineItems.isEmpty ? ["No line items confidently parsed"] : []

        return [
            "document_id": UUID().uuidString.lowercased(),
            "document_type": docType,
            "locale": "\(language)-US",
            "currency": currency,
            "images": imagesPayload,
            "header": [
                "document_number": ns(invoiceNumber ?? receiptNumber),
                "invoice_number": ns(invoiceNumber),
                "receipt_number": ns(receiptNumber),
                "po_number": ns(poNumber),
                "order_number": ns(orderNumber),
                "date_issued": ns(dateIssued),
                "time_issued": ns(timeIssued),
                "page": uris.count,
                "total_pages": uris.count
            ],
            "vendor": [
                "name": ns(vendorName),
                "branch": ns(vendorBranch),
                "tax_id": ns(vendorTaxId),
                "address_lines": vendorAddressLines,
                "city": ns(parseCityStatePostal(vendorAddressLines.joined(separator: ", ")).city),
                "state": ns(parseCityStatePostal(vendorAddressLines.joined(separator: ", ")).state),
                "postal_code": ns(parseCityStatePostal(vendorAddressLines.joined(separator: ", ")).postalCode),
                "country": NSNull(),
                "phone": ns(vendorPhone),
                "email": ns(vendorEmail),
                "website": ns(vendorWebsite)
            ],
            "buyer": [
                "name": ns(buyer.name),
                "account_id": ns(customerId),
                "address_lines": buyer.addressLines,
                "city": ns(buyer.city),
                "state": ns(buyer.state),
                "postal_code": ns(buyer.postalCode),
                "country": NSNull()
            ],
            "line_items": lineItems,
            "totals": [
                "sub_total": rounded(subTotal, digits: 2),
                "discount_total": rounded(discountTotal, digits: 2),
                "total_tax": rounded(totalTax, digits: 2),
                "shipping_total": rounded(shippingTotal, digits: 2),
                "grand_total": rounded(grandTotal, digits: 2),
                "amount_paid": ns(amountPaid != nil ? rounded(amountPaid!, digits: 2) : nil),
                "amount_due": rounded(amountDue, digits: 2)
            ],
            "payment": [
                "payment_method": ns(cardBrand ?? paymentMethod),
                "masked_account": ns(maskedAccount),
                "authorization_code": ns(authCode),
                "aid": ns(aid),
                "cryptogram": ns(cryptogram),
                "tender_type": ns(cardBrand ?? paymentMethod)
            ],
            "taxes": [
                [
                    "tax_name": "Tax",
                    "tax_rate": NSNull(),
                    "tax_amount": rounded(totalTax, digits: 2)
                ]
            ],
            "remittance": [
                "remit_to_name": ns(remittanceData.name),
                "remit_to_address_lines": remittanceData.addressLines
            ],
            "audit": [
                "ocr_engine": "AppleVision",
                "extraction_timestamp": ISO8601DateFormatter().string(from: Date()),
                "confidence": confidenceMap,
                "warnings": warnings
            ]
        ]
    }

    private func buildInvoiceSchema(
        text: String,
        image: UIImage,
        language: String,
        ocrConfidence: Float
    ) -> [String: Any] {
        let lines = text
            .split(separator: "\n")
            .map { String($0).trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }

        let invoiceNumber = firstMatch(
            in: text,
            pattern: "(?:invoice\\s*(?:no\\.?|#|number)?|inv\\s*[#:])\\s*([A-Z0-9][A-Z0-9\\-\\/]{1,30})"
        )
        let invoiceDate = firstMatch(
            in: text,
            pattern: "(?:invoice\\s*date|date)\\s*[:\\-]?\\s*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{1,2}[\\/\\-][0-9]{1,2}[\\/\\-][0-9]{2,4})"
        )
        let dueDate = firstMatch(
            in: text,
            pattern: "(?:due\\s*date|due)\\s*[:\\-]?\\s*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{1,2}[\\/\\-][0-9]{1,2}[\\/\\-][0-9]{2,4})"
        )
        let currency = detectCurrency(in: text)

        let vendorName = extractVendorName(lines: lines)
        let buyerName = extractBuyerName(lines: lines)
        let lineItems = extractLineItems(lines: lines)

        let subTotal = firstAmount(
            in: text,
            labels: ["sub total", "subtotal"]
        ) ?? lineItems.reduce(0.0) { sum, item in
            let amount = item["total_amount"] as? Double ?? 0.0
            return sum + amount
        }
        let taxTotal = firstAmount(in: text, labels: ["tax total", "total tax", "tax", "vat", "gst"]) ?? 0.0
        let discountTotal = firstAmount(in: text, labels: ["discount", "discount total"]) ?? 0.0
        let shipping = firstAmount(in: text, labels: ["shipping", "delivery", "freight"]) ?? 0.0
        let grandTotal = firstAmount(
            in: text,
            labels: ["grand total", "total amount due", "amount due", "total"]
        ) ?? (subTotal + taxTotal + shipping - discountTotal)
        let amountDue = firstAmount(in: text, labels: ["amount due", "balance due"]) ?? grandTotal

        let paymentTerms = firstMatch(
            in: text,
            pattern: "(?:payment\\s*terms?|terms?)\\s*[:\\-]?\\s*(net\\s*\\d+|cod|prepaid|due\\s*on\\s*receipt)"
        )
        let paymentMethod = firstMatch(
            in: text,
            pattern: "(?:payment\\s*(?:method|mode)|paid\\s*by|payment)\\s*[:\\-]?\\s*([A-Za-z][A-Za-z\\s]{2,40})"
        )
        let bankAccount = firstMatch(
            in: text,
            pattern: "(?:bank\\s*account|account\\s*number|acct)\\s*[:\\-]?\\s*([A-Z0-9\\-]{4,40})"
        )

        let schemaConfidence = estimateSchemaConfidence(
            invoiceNumber: invoiceNumber,
            invoiceDate: invoiceDate,
            vendorName: vendorName,
            lineItems: lineItems,
            grandTotal: grandTotal
        )
        let extractionConfidence = rounded(
            (Double(ocrConfidence) * 0.7) + (schemaConfidence * 0.3),
            digits: 2
        )

        var fieldConfidences: [String: Any] = [:]
        if invoiceNumber != nil { fieldConfidences["invoice_number"] = extractionConfidence }
        if invoiceDate != nil { fieldConfidences["invoice_date"] = extractionConfidence }
        if !lineItems.isEmpty { fieldConfidences["line_items[0].description"] = extractionConfidence }

        return [
            "schemaVersion": "1.0.0",
            "document_id": UUID().uuidString.lowercased(),
            "invoice_number": ns(invoiceNumber),
            "invoice_date": ns(invoiceDate),
            "due_date": ns(dueDate),
            "currency": currency,
            "vendor": [
                "name": ns(vendorName),
                "address": [
                    "lines": [],
                    "city": NSNull(),
                    "region": NSNull(),
                    "postal_code": NSNull(),
                    "country_code": NSNull()
                ],
                "tax_id": ns(firstMatch(in: text, pattern: "(?:tax\\s*id|tin|ein)\\s*[:\\-]?\\s*([A-Z0-9\\-]{5,30})")),
                "contact": [
                    "phone": ns(firstMatch(in: text, pattern: "(?:\\+?\\d[\\d\\s\\-()]{6,}\\d)")),
                    "email": ns(firstMatch(in: text, pattern: "([A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,})"))
                ]
            ],
            "buyer": [
                "name": ns(buyerName),
                "address": [
                    "lines": [],
                    "city": NSNull(),
                    "region": NSNull(),
                    "postal_code": NSNull(),
                    "country_code": NSNull()
                ]
            ],
            "line_items": lineItems,
            "taxes": [
                [
                    "name": "Tax",
                    "rate": NSNull(),
                    "amount": taxTotal
                ]
            ],
            "totals": [
                "sub_total": rounded(subTotal, digits: 2),
                "tax_total": rounded(taxTotal, digits: 2),
                "discount_total": rounded(discountTotal, digits: 2),
                "shipping": rounded(shipping, digits: 2),
                "grand_total": rounded(grandTotal, digits: 2),
                "amount_due": rounded(amountDue, digits: 2),
                "currency": currency
            ],
            "payment": [
                "terms": ns(paymentTerms),
                "method": ns(paymentMethod),
                "bank_account": ns(bankAccount)
            ],
            "extraction_confidence": extractionConfidence,
            "field_confidences": fieldConfidences,
            "ocr_metadata": [
                "engine": "AppleVision",
                "engine_version": "native",
                "language": language,
                "pages": [
                    [
                        "page_number": 0,
                        "width": Int(image.size.width),
                        "height": Int(image.size.height),
                        "units": "px",
                        "confidence": rounded(Double(ocrConfidence), digits: 2)
                    ]
                ]
            ],
            "processing_notes": ["Generated by native invoice schema extractor"]
        ]
    }

    private func mapUnifiedLineItems(_ items: [[String: Any]]) -> [[String: Any]] {
        return items.enumerated().map { idx, item in
            [
                "line_id": "\(idx + 1)",
                "sku": ns(item["sku"]),
                "description": ns(item["description"]),
                "quantity": ns(item["quantity"]),
                "uom": ns(item["uom"]),
                "unit_price": ns(item["unit_price"]),
                "discount": NSNull(),
                "extended_price": ns(item["total_amount"]),
                "taxes": []
            ]
        }
    }

    private func detectDocumentType(text: String, hasInvoiceNumber: Bool, hasReceiptNumber: Bool) -> String {
        let lower = text.lowercased()
        if hasInvoiceNumber || lower.contains("invoice") { return "invoice" }
        if hasReceiptNumber || lower.contains("receipt") {
            if lower.contains("pos") { return "pos_receipt" }
            if lower.contains("payment") { return "payment_receipt" }
            return "receipt"
        }
        if lower.contains("credit memo") { return "credit_memo" }
        if lower.contains("remittance") { return "remittance" }
        return "invoice"
    }

    private func extractVendorAddressLines(lines: [String]) -> [String] {
        var output: [String] = []
        for line in lines.prefix(12) {
            let lower = line.lowercased()
            if lower.contains("invoice") || lower.contains("bill to") || lower.contains("ship to") { continue }
            if line.count >= 5 { output.append(line) }
            if output.count >= 3 { break }
        }
        return output
    }

    private func extractBuyer(lines: [String]) -> (name: String?, addressLines: [String], city: String?, state: String?, postalCode: String?) {
        for index in 0..<lines.count {
            let lower = lines[index].lowercased()
            if lower.contains("bill to") || lower.contains("buyer") || lower.contains("customer") || lower.contains("sold to") {
                var block: [String] = []
                for j in (index + 1)..<min(index + 6, lines.count) {
                    let line = lines[j]
                    if line.lowercased().contains("ship to") || line.lowercased().contains("subtotal") { break }
                    block.append(line)
                }
                let name = block.first
                let addressLines = Array(block.dropFirst(1).prefix(3))
                let parsed = parseCityStatePostal(addressLines.joined(separator: ", "))
                return (name, addressLines, parsed.city, parsed.state, parsed.postalCode)
            }
        }
        return (nil, [], nil, nil, nil)
    }

    private func parseCityStatePostal(_ text: String) -> (city: String?, state: String?, postalCode: String?) {
        guard let regex = try? NSRegularExpression(pattern: "([A-Za-z][A-Za-z\\s]{1,30}),?\\s+([A-Z]{2})\\s+(\\d{5}(?:-\\d{4})?)", options: []) else {
            return (nil, nil, nil)
        }
        let ns = text as NSString
        let range = NSRange(location: 0, length: ns.length)
        guard let m = regex.firstMatch(in: text, options: [], range: range), m.numberOfRanges >= 4 else {
            return (nil, nil, nil)
        }
        return (
            ns.substring(with: m.range(at: 1)).trimmingCharacters(in: .whitespacesAndNewlines),
            ns.substring(with: m.range(at: 2)).trimmingCharacters(in: .whitespacesAndNewlines),
            ns.substring(with: m.range(at: 3)).trimmingCharacters(in: .whitespacesAndNewlines)
        )
    }

    private func normaliseDate(_ raw: String?) -> String? {
        // ::: Code Generated by Copilot [c4ab5f23-286b-45ef-9167-776c6fd1d8ec]. This comment will be removed automatically after the file is saved :::
        guard let raw = raw, !raw.isEmpty else { return nil }
        if raw.range(of: "^\\d{4}-\\d{2}-\\d{2}$", options: .regularExpression) != nil {
            return raw
        }
        let parts = raw.replacingOccurrences(of: "-", with: "/").split(separator: "/")
        if parts.count == 3 {
            if parts[0].count == 4 {
                let yyyy = String(parts[0])
                let mm = String(format: "%02d", Int(parts[1]) ?? 1)
                let dd = String(format: "%02d", Int(parts[2]) ?? 1)
                return "\(yyyy)-\(mm)-\(dd)"
            }
            let mm = String(format: "%02d", Int(parts[0]) ?? 1)
            let dd = String(format: "%02d", Int(parts[1]) ?? 1)
            var yyyy = String(parts[2])
            if yyyy.count == 2 {
                yyyy = "20\(yyyy)"
            }
            return "\(yyyy)-\(mm)-\(dd)"
        }
        return raw
    }

    private func normaliseTime(_ raw: String?) -> String? {
        guard let raw = raw else { return nil }
        let p = raw.split(separator: ":")
        guard p.count >= 2 else { return nil }
        let hh = String(format: "%02d", Int(p[0]) ?? 0)
        let mm = String(format: "%02d", Int(p[1]) ?? 0)
        if p.count >= 3 {
            let ss = String(format: "%02d", Int(p[2]) ?? 0)
            return "\(hh):\(mm):\(ss)"
        }
        return "\(hh):\(mm)"
    }

    private func extractVendorName(lines: [String]) -> String? {
        for line in lines.prefix(8) {
            if line.count < 3 { continue }
            let lower = line.lowercased()
            if lower.contains("invoice") || lower.contains("bill to") || lower.contains("date") { continue }
            return line
        }
        return nil
    }

    private func extractBuyerName(lines: [String]) -> String? {
        for index in 0..<lines.count {
            let lower = lines[index].lowercased()
            if lower.contains("bill to") || lower.contains("buyer") || lower.contains("customer") {
                if index + 1 < lines.count {
                    return lines[index + 1]
                }
            }
        }
        return nil
    }

    // ::: Code Generated by Copilot [d8a1e4f7-9b3c-42d5-a6e8-1f2d3c4b5a69]. This comment will be removed automatically after the file is saved :::
    private func extractLineItems(lines: [String]) -> [[String: Any]] {
        var items: [[String: Any]] = []

        // Strategy 1: Standard pattern - desc qty unitPrice total
        let stdPattern = "^\\s*(?:\\d+[\\).\\-]?\\s+)?([A-Za-z][A-Za-z0-9\\-\\s,./()\"]{2,}?)\\s+(\\d+(?:\\.\\d+)?)\\s+(\\d{1,3}(?:,\\d{3})*(?:\\.\\d{1,4})?)\\s+(\\d{1,3}(?:,\\d{3})*(?:\\.\\d{1,4})?)\\s*$"
        let skuExtractPattern = "\\b(\\d{4,8}[A-Z]?\\d*|[A-Z]{1,4}\\d{2,}[A-Z0-9\\-]*|\\d{2,}-\\d{2,}(?:-\\d+)?)\\b"
        let uomExtractPattern = "\\b(EA|EACH|PC|PCS|BOX|CTN|PKG|SET|LB|KG|FT|GAL|OZ)\\b"

        var lineNumber = 1
        for line in lines {
            guard let description = firstMatch(in: line, pattern: stdPattern, group: 1),
                  let qtyText = firstMatch(in: line, pattern: stdPattern, group: 2),
                  let unitPriceText = firstMatch(in: line, pattern: stdPattern, group: 3),
                  let totalText = firstMatch(in: line, pattern: stdPattern, group: 4),
                  let quantity = Double(qtyText.replacingOccurrences(of: ",", with: "")),
                  let unitPrice = Double(unitPriceText.replacingOccurrences(of: ",", with: "")),
                  let totalAmount = Double(totalText.replacingOccurrences(of: ",", with: ""))
            else {
                continue
            }
            items.append([
                "line_number": lineNumber,
                "sku": ns(firstMatch(in: line, pattern: skuExtractPattern)),
                "description": description.trimmingCharacters(in: .whitespacesAndNewlines),
                "quantity": rounded(quantity, digits: 2),
                "uom": ns(firstMatch(in: line, pattern: uomExtractPattern)),
                "unit_price": rounded(unitPrice, digits: 4),
                "total_amount": rounded(totalAmount, digits: 2)
            ])
            lineNumber += 1
        }

        // Strategy 2: Price-trailing pattern - lines ending with unitPrice extendedPrice
        if items.isEmpty {
            let priceTrailRx = try? NSRegularExpression(
                pattern: "(\\d{1,3}(?:,\\d{3})*\\.\\d{2,4})\\s+(\\d{1,3}(?:,\\d{3})*\\.\\d{2,4})\\s*$",
                options: []
            )
            let skipRx = try? NSRegularExpression(
                pattern: "^(carrier|tracking|page\\s+\\d|ordered\\s+shipped|quantities|unit\\s*size)",
                options: [.caseInsensitive]
            )
            let leadingQtyRx = try? NSRegularExpression(
                pattern: "^(?:\\d+(?:\\.\\d+)?\\s+){1,4}",
                options: []
            )
            let leadingUomRx = try? NSRegularExpression(
                pattern: "^[A-Z]{2,5}\\s+\\d+(?:\\.\\d+)?\\s+",
                options: []
            )
            let trailingUomRx = try? NSRegularExpression(
                pattern: "\\s+(?:EA|PC|EACH|BOX|CTN)(?:\\s+\\d+(?:\\.\\d+)?)?\\s*$",
                options: [.caseInsensitive]
            )

            // Find table body: between header row and totals
            let headerIdx = lines.firstIndex { line in
                let l = line.lowercased()
                return (l.contains("description") || l.contains("item id")) &&
                       (l.contains("price") || l.contains("amount") || l.contains("total"))
            } ?? -1

            let totalsKws = ["sub total", "subtotal", "total tax", "tax total", "grand total", "amount due", "amount paid", "credit card", "incoterms", "total lines"]
            var totalsIdx = lines.count
            for i in max(headerIdx + 1, lines.count / 3)..<lines.count {
                let l = lines[i].lowercased()
                if totalsKws.contains(where: { l.hasPrefix($0) || l.contains("sub-total") || l.contains("total lines") }) {
                    totalsIdx = i
                    break
                }
            }

            let bodyStart = max(0, headerIdx + 1)
            let bodyLines = Array(lines[bodyStart..<totalsIdx])

            for i in 0..<bodyLines.count {
                let line = bodyLines[i]
                if line.count < 5 { continue }

                let nsLine = line as NSString
                let lineRange = NSRange(location: 0, length: nsLine.length)
                if skipRx?.firstMatch(in: line, options: [], range: lineRange) != nil { continue }

                guard let priceMatch = priceTrailRx?.firstMatch(in: line, options: [], range: lineRange),
                      priceMatch.numberOfRanges >= 3 else {
                    // Continuation line
                    if !items.isEmpty && line.count > 2 && line.first?.isLetter == true {
                        let hasDecimals = line.range(of: "\\d{2,}\\.\\d{2}", options: .regularExpression) != nil
                        if !hasDecimals {
                            if var desc = items[items.count - 1]["description"] as? String, desc.count < 120 {
                                desc += " " + line.trimmingCharacters(in: .whitespacesAndNewlines)
                                items[items.count - 1]["description"] = desc
                            }
                        }
                    }
                    continue
                }

                let upStr = nsLine.substring(with: priceMatch.range(at: 1))
                let epStr = nsLine.substring(with: priceMatch.range(at: 2))
                guard let unitPrice = Double(upStr.replacingOccurrences(of: ",", with: "")),
                      let extPrice = Double(epStr.replacingOccurrences(of: ",", with: "")) else { continue }

                var textPart = nsLine.substring(to: priceMatch.range(at: 0).location)
                    .trimmingCharacters(in: .whitespacesAndNewlines)

                // Strip leading qty columns and UOM prefix
                if let rx = leadingQtyRx {
                    let r = NSRange(location: 0, length: (textPart as NSString).length)
                    textPart = rx.stringByReplacingMatches(in: textPart, options: [], range: r, withTemplate: "")
                        .trimmingCharacters(in: .whitespacesAndNewlines)
                }
                if let rx = leadingUomRx {
                    let r = NSRange(location: 0, length: (textPart as NSString).length)
                    textPart = rx.stringByReplacingMatches(in: textPart, options: [], range: r, withTemplate: "")
                        .trimmingCharacters(in: .whitespacesAndNewlines)
                }

                let sku = firstMatch(in: textPart, pattern: skuExtractPattern)
                var description = sku != nil
                    ? textPart.replacingOccurrences(of: sku!, with: "").trimmingCharacters(in: .whitespacesAndNewlines)
                    : textPart

                if let rx = trailingUomRx {
                    let r = NSRange(location: 0, length: (description as NSString).length)
                    description = rx.stringByReplacingMatches(in: description, options: [], range: r, withTemplate: "")
                        .trimmingCharacters(in: .whitespacesAndNewlines)
                }

                let uom = firstMatch(in: line, pattern: uomExtractPattern)
                let qty = unitPrice > 0 ? (extPrice / unitPrice).rounded() : 1.0

                if description.count < 2 { continue }

                items.append([
                    "line_number": lineNumber,
                    "sku": ns(sku),
                    "description": description,
                    "quantity": rounded(qty, digits: 2),
                    "uom": ns(uom),
                    "unit_price": rounded(unitPrice, digits: 4),
                    "total_amount": rounded(extPrice, digits: 2)
                ])
                lineNumber += 1
            }
        }

        if items.isEmpty {
            return [[
                "line_number": 1,
                "sku": NSNull(),
                "description": "Unparsed item",
                "quantity": 1,
                "uom": NSNull(),
                "unit_price": 0,
                "total_amount": 0
            ]]
        }

        return items
    }

    // ::: Code Generated by Copilot [d8a1e4f7-9b3c-42d5-a6e8-1f2d3c4b5a69]. This comment will be removed automatically after the file is saved :::
    private func firstAmount(in text: String, labels: [String]) -> Double? {
        for label in labels {
            let escapedLabel = NSRegularExpression.escapedPattern(for: label)
            let pattern = "(?:\\b" + escapedLabel + "\\b)\\s*[:\\-]?\\s*(?:[A-Z]{3}\\s*)?[$]?\\s*(\\d{1,3}(?:,\\d{3})*(?:\\.\\d{1,2})?)"
            if let value = firstMatch(in: text, pattern: pattern),
               let number = Double(value.replacingOccurrences(of: ",", with: "")) {
                return number
            }
        }
        return nil
    }

    private func extractBranch(lines: [String]) -> String? {
        for line in lines.prefix(10) {
            if let match = firstMatch(in: line, pattern: "branch\\s*[:#]?\\s*\\d*\\s+(.+)") {
                return match.trimmingCharacters(in: .whitespacesAndNewlines)
            }
        }
        return nil
    }

    private func extractCustomerId(text: String) -> String? {
        return firstMatch(in: text, pattern: "customer\\s*(?:id|#|no\\.?)\\s*[:#]?\\s*(\\S+)")
    }

    private func extractRemittance(text: String) -> (name: String?, addressLines: [String]) {
        let lower = text.lowercased()
        var searchRange: Range<String.Index>?

        if let r = lower.range(of: "remittance address") {
            searchRange = r.upperBound..<text.endIndex
        } else if let r = lower.range(of: "mail paper checks to") {
            searchRange = r.upperBound..<text.endIndex
        }
        guard let range = searchRange else { return (nil, []) }

        let afterText = String(text[range])
        let lines = afterText.split(separator: "\n").map { String($0).trimmingCharacters(in: .whitespacesAndNewlines) }

        var addressLines: [String] = []
        for line in lines {
            if line.isEmpty || line.allSatisfy({ $0 == "*" }) { continue }
            let lower = line.lowercased()
            if lower.hasPrefix("see ") || lower.hasPrefix("these ") || lower.hasPrefix("hydraulic") { break }
            if lower.hasPrefix("mail paper") { continue }
            if line.count > 80 { break }
            addressLines.append(line)
            if addressLines.count >= 4 { break }
        }

        return ("NEW REMITTANCE ADDRESS", addressLines)
    }

    private func firstMatch(in text: String, pattern: String, group: Int = 1) -> String? {
        guard let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]) else {
            return nil
        }
        let nsText = text as NSString
        let range = NSRange(location: 0, length: nsText.length)
        guard let match = regex.firstMatch(in: text, options: [], range: range),
              match.numberOfRanges > group
        else {
            return nil
        }

        let matchRange = match.range(at: group)
        guard matchRange.location != NSNotFound else { return nil }
        return nsText.substring(with: matchRange).trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private func detectCurrency(in text: String) -> String {
        let upper = text.uppercased()
        if upper.contains("USD") || text.contains("$") { return "USD" }
        if upper.contains("EUR") || text.contains("") { return "EUR" }
        if upper.contains("GBP") || text.contains("") { return "GBP" }
        if upper.contains("INR") || text.contains("") { return "INR" }
        return "USD"
    }

    private func estimateSchemaConfidence(
        invoiceNumber: String?,
        invoiceDate: String?,
        vendorName: String?,
        lineItems: [[String: Any]],
        grandTotal: Double
    ) -> Double {
        var score = 0.0
        if invoiceNumber != nil { score += 0.2 }
        if invoiceDate != nil { score += 0.2 }
        if vendorName != nil { score += 0.2 }
        if !lineItems.isEmpty { score += 0.2 }
        if grandTotal > 0 { score += 0.2 }
        return score
    }

    private func rounded(_ value: Double, digits: Int) -> Double {
        let divisor = pow(10.0, Double(digits))
        return (value * divisor).rounded() / divisor
    }

    private func ns(_ value: Any?) -> Any {
        return value ?? NSNull()
    }
}

// MARK: - DataLiftError

enum DataLiftError: Error {
    case invalidInput(String)
    case ocrFailed(String)
    case classificationFailed(String)
    case pdfFailed(String)

    var code: String {
        switch self {
        case .invalidInput: return "INVALID_INPUT"
        case .ocrFailed: return "OCR_ERROR"
        case .classificationFailed: return "CLASSIFICATION_ERROR"
        case .pdfFailed: return "PDF_ERROR"
        }
    }

    var message: String {
        switch self {
        case .invalidInput(let msg),
             .ocrFailed(let msg),
             .classificationFailed(let msg),
             .pdfFailed(let msg):
            return msg
        }
    }
}
